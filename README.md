# Тесты к курсу «Парадигмы программирования»

[Условия домашних заданий](https://www.kgeorgiy.info/courses/paradigms/homeworks.html)

## Домашнее задание 10. Функциональные выражения на Clojure

Модификации
 * *Base*
    * Код должен находиться в файле `clojure-solutions/expression.clj`.
    * [Исходный код тестов](clojure/cljtest/functional/FunctionalTest.java)
        * Запускать c указанием модификации и сложности (`easy` или `hard`).
 * *MeanVarn* (36, 37). Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `mean` – математическое ожидание аргументов, `(mean 1 2 6)` равно 3;
        * `varn` – дисперсия аргументов, `(varn 2 5 11)` равно 14.
 * *Means* (38, 39). Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `ArithMean` (`arithMean`) – арифметическое среднее `(arithMean 1 2 6)` равно 3;
        * `GeomMean` (`geomMean`) – геометрическое среднее `(geomMean 1 2 4)` равно 2;
        * `HarmMean` (`harmMean`) – гармоническое среднее, `(harmMean 2 3 6)` равно 3.


## Домашнее задание 9. Линейная алгебра на Clojure

Модификации
 * *Базовая*
    * Код должен находиться в файле `clojure-solutions/linear.clj`.
    * [Исходный код тестов](clojure/cljtest/linear/LinearTest.java)
        * Запускать c указанием сложности (`easy` или `hard`) и модификации.
 * *Cuboid* (32, 33)
    * Назовем _кубоидом_ трёхмерную прямоугольную таблицу чисел.
    * Добавьте операции поэлементного
        сложения (`c+`), вычитания (`c-`), умножения (`c*`) и деления (`cd`)
        кубоидов.
        Например, `(c+ [[[1] [2]] [[3] [4]]] [[[5] [6]] [[7] [8]]])`
        должно быть равно `[[[6] [8]] [[10] [12]]]`.
 * *Cuboid4* (34, 35)
    * Назовем _четырёхмерным кубоидом_ четырёхмерную прямоугольную таблицу чисел.
    * Добавьте операции поэлементного
        сложения (`c4+`), вычитания (`c4-`), умножения (`c4*`) и деления (`c4d`)
        четырёхмерных кубоидов.
        Например, `(c4+ [[[[1] [2]] [[3] [4]] [[5] [6]] [[7] [8]]]] [[[[9] [10]] [[11] [12]] [[13] [14]] [[15] [16]]]])`
        должно быть равно `[[[[10] [12]] [[14] [16]] [[18] [20]] [[22] [24]]]]`.
 * *Simplex* (36, 37)
    * Назовем _симплексом_ многомерную таблицу чисел,
      такую что для некоторого `n` в ней существуют все значения
      с суммой индексов не превышающей `n` и только эти значения.
    * Добавьте операции поэлементного
        сложения (`x+`), вычитания (`x-`), умножения (`x*`) и деления (`xd`)
        симплексов.
        Например, `(x+ [[1 2] [3]] [[5 6] [7]])`
        должно быть равно `[[6 8] [10]]`.
    * [Исходный код тестов](clojure/cljtest/linear/SimplexTester.java)
 * *Broadcast* (38, 39)
    * Назовем _тензором_ многомерную прямоугольную таблицу чисел.
    * _Форма_ тензора – последовательность чисел
        (_s_<sub>1..n</sub>)=(_s_<sub>1</sub>, _s_<sub>2</sub>, …, _s<sub>n</sub>_), где
        _n_ – размерность тензора, а _s<sub>i</sub>_ – число элементов
        по _i_-ой оси.
      Например, форма тензора `[[[2 3 4] [5 6 7]]]`  равна (1, 2, 3),
      а форма `1` равна ().
    * Тензор формы (_s_<sub>1.._n_</sub>) может быть _распространен_ (broadcast)
      до тензора формы (_u_<sub>1.._m_</sub>), если (_s_<sub>i.._n_</sub>) является
      суффиксом (_u<sub>1..m</sub>_).
      Для этого, исходный тензор копируется по недостающим осям.
      Например, распространив тензор `[ [2] [3] ]` формы (2, 1) до
      формы (3, 2, 1) получим `[ [ [2] [3] ] [ [2] [3] ] [ [2] [3] ] ]`,
      а распространив `1` до формы (2, 3) получим `[ [1 1 1] [1 1 1] ]`.
    * Тензоры называются совместимыми, если один из них может быть распространен
      до формы другого.
      Например, тензоры формы (3, 2, 1) и (2, 1) совместимы, а
      (3, 2, 1) и (1, 2) – нет. Числа совместимы с тензорами любой формы.
    * Добавьте операции поэлементного
      сложения (`h+`), вычитания (`h-`), умножения (`h*`) и деления (`hd`)
      совместимых тензоров.
      Если формы тензоров не совпадают, то тензоры меньшей размерности
      должны быть предварительно распространены до тензоров большей размерности.
      Например, `(h+ 1 [ [10 20 30] [40 50 60] ] [100 200 300] )`
      должно быть равно `[ [111 221 331] [141 251 361] ]`.
    * [Исходный код тестов](clojure/cljtest/linear/BroadcastTester.java)


## Исходный код к лекциям по Clojure

Документация
 * [Clojure Reference](https://clojure.org/reference/documentation)
 * [Clojure Cheat Sheet](https://clojure.org/api/cheatsheet)

Запуск Clojure
 * Консоль: [Windows](clojure/RunClojure.cmd), [*nix](clojure/RunClojure.sh)
    * Интерактивный: `RunClojure`
    * С выражением: `RunClojure --eval "<выражение>"`
    * Скрипт: `RunClojure <файл скрипта>`
    * Справка: `RunClojure --help`
 * IDE
    * IntelliJ Idea: [плагин Cursive](https://cursive-ide.com/userguide/)
    * Eclipse: [плагин Counterclockwise](https://marketplace.eclipse.org/content/counterclockwise)

[Скрипт со всеми примерами](clojure/examples.clj)

Лекция 1. Функции
 * [Введение](clojure/examples/1_1_intro.clj)
 * [Функции](clojure/examples/1_2_functions.clj)
 * [Списки](clojure/examples/1_3_lists.clj)
 * [Вектора](clojure/examples/1_4_vectors.clj)
 * [Функции высшего порядка](clojure/examples/1_5_functions-2.clj)

Лекция 2. Внешний мир
 * [Ввод-вывод](clojure/examples/2_1_io.clj)
 * [Разбор и гомоиконность](clojure/examples/2_2_read.clj)
 * [Порядки вычислений](clojure/examples/2_3_evaluation-orders.clj)
 * [Потоки](clojure/examples/2_4_streams.clj)
 * [Отображения и множества](clojure/examples/2_5_maps.clj)


## Тестовое задание на Clojure

Это задание преднозначено для проверки правильности настройки Clojure.
Вам надо проверить, что оно успешно проверяется на вашем компьютере.

Для запуска тестов используются скрипты
[TestClojure.cmd](clojure/TestClojure.cmd) и [TestClojure.sh](clojure/TestClojure.sh)
 * Репозиторий должен быть скачан целиком.
 * Скрипты должны находиться в каталоге `clojure`
    (их нельзя перемещать, но можно вызывать из других каталогов).
 * Тестируемое решение должно находиться в текущем каталоге.
 * В качестве аргументов командной строки указывается
   полное имя класса теста, сложность и модификация,
   например, `cljtest.example.ExampleTest hard base`.

Модификации
 * *base*
    * Код решения `clojure-solutions/example.clj`
    * [Исходный код тестов](clojure/cljtest/example/ExampleTest.java)
        * Запускать c аргументом `hard` или `easy`.


## Домашнее задание 8. Обработка ошибок на JavaScript

Модификации
 * *Base*
    * Код должен находиться в файле `javascript-solutions/objectExpression.js`.
    * [Исходный код тестов](javascript/jstest/prefix/ParserTest.java)
        * Запускать c указанием модификации и сложности (`easy` или `hard`).
 * *Prefix*: *MeanVar* (32, 33). Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `Mean` (`mean`) – математическое ожидание аргументов, `(mean 1 2 6)` равно 3;
        * `Var` (`var`) – дисперсия аргументов, `(var 2 5 11)` равно 14.
    * [Исходный код тестов](javascript/jstest/prefix/ParserTest.java)
 * *Prefix*: *ProdGeom* (34, 35). Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `Product` (`product`) – произведение, `(product 1 2 4)` равно 8;
        * `Geom` (`geom`) – геометрическое среднее, `(geom 1 2 4)` равно 2.
    * [Исходный код тестов](javascript/jstest/prefix/ParserTest.java)
 * *Postfix* (36-39). Дополнительно реализовать поддержку:
    * Выражений в постфиксной записи:
        * `(2 3 +)` равно 5
        * функция `parsePostfix`
        * метод `postfix`
    * [Исходный код тестов](javascript/jstest/prefix/PostfixTest.java)
        * Запускать c указанием модификации и сложности (`easy` или `hard`).
 * *Postfix*: *MeanVar* (36, 37). Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `Mean` (`mean`) – математическое ожидание аргументов, `(1 2 6 mean)` равно 3;
        * `Var` (`var`) – дисперсия аргументов, `(2 5 11 var)` равно 14.
 * *Postfix*: *Means* (38, 39). Дополнительно реализовать поддержку:
    * операций произвольного числа аргументов:
        * `ArithMean` (`arithMean`) – арифметическое среднее `(1 2 6 arithMean)` равно 3;
        * `GeomMean` (`geomMean`) – геометрическое среднее `(1 2 4 geomMean)` равно 2;
        * `HarmMean` (`harmMean`) – гармоническое среднее, `(2 3 6 harmMean)` равно 3.
    * [Исходный код тестов](javascript/jstest/prefix/PostfixTest.java)


## Домашнее задание 7. Объектные выражения на JavaScript

Модификации
 * *Base*
    * Код должен находиться в файле `javascript-solutions/objectExpression.js`.
    * [Исходный код тестов](javascript/jstest/object/ObjectTest.java)
        * Запускать c указанием модификации и сложности (`easy`, `hard` или `bonus`).
 * *SinCos* (32, 33). Дополнительно реализовать поддержку:
    * унарных функций:
        * `Sin` (`sin`) – синус, `3.14159265 sin` примерно равно 0;
        * `Cos` (`cos`) – косинус, `3.14159265 cos` примерно равно -1.
 * *SinhCosh* (34, 35). Дополнительно реализовать поддержку:
    * унарных функций:
        * `Sinh` (`sinh`) – гиперболический синус, `3 sinh` немного больше 10;
        * `Cosh` (`cosh`) – гиперболический косинус, `3 cosh` немного меньше 10.
 * *ArcTan* (36, 37). Дополнительно реализовать поддержку:
    * функций:
        * `ArcTan` (`atan`) – арктангенс, `1256 atan` примерно равно 1.57;
        * `ArcTan2` (`atan2`) – арктангенс, `841 540 atan2` примерно равно 1.
 * *Harmonic* (38, 39). Дополнительно реализовать поддержку:
    * функций от двух аргументов:
        * `Hypot` (`hypot`) – квадрат гипотенузы, `3 4 hypot` равно 25;
        * `HMean` (`hmean`) – гармоническое среднее, `5 20 hmean` равно 8.


## Домашнее задание 6. Функциональные выражения на JavaScript

Модификации
 * *Базовая*
    * Код должен находиться в файле `javascript-solutions/functionalExpression.js`.
    * [Исходный код тестов](javascript/jstest/functional/FunctionalTest.java)
        * Запускать c аргументом `hard` или `easy`.
 * *Pie* (32-39). Дополнительно реализовать поддержку:
    * констант:
        * `pi` – π;
        * `e` – основание натурального логарифма;
 * *PieSquare* (32, 33). Дополнительно реализовать поддержку:
    * модификации *Pie*
    * унарных функций:
        * `Square` (`square`) – возведение в квадрат, `3 square` равно 9;
        * `Sqrt` (`sqrt`) – извлечение квадратного корня из модуля аргумента, `-9 sqrt` равно 3.
 * *PieCube* (34, 35). Дополнительно реализовать поддержку:
    * модификации *Pie*
    * унарных функций:
        * `Cube` (`cube`) – возведение в куб, `-3 cube` равно −27;
        * `Cbrt` (`cbrt`) – извлечение кубического корня, `-27 cbrt` равно −3.
 * *PieMinMax* (36, 37). Дополнительно реализовать поддержку:
    * модификации *Pie*
    * операций:
        * `min5` – минимальный из пяти аргументов, `3 1 4 1 5 min5` равно 1;
        * `max3` – максимальный из трёх аргументов, `3 1 4 max3` равно 4.
 * *PieAvgMed* (38, 39). Дополнительно реализовать поддержку:
    * модификации *Pie*
    * операций:
        * `avg5` – арифметическое среднее пяти аргументов, `1 2 3 4 5 avg5` равно 3;
        * `med3` – медиана трёх аргументов, `1 2 -10 med3` равно 1.


## Исходный код к лекциям по JavaScript

[Скрипт с примерами](javascript/examples.js)

Запуск примеров
 * [В браузере](javascript/RunJS.html)
 * Из консоли
    * [на Java](javascript/RunJS.java): [RunJS.cmd](javascript/RunJS.cmd), [RunJS.sh](javascript/RunJS.sh)
    * [на node.js](javascript/RunJS.node.js): `node RunJS.node.js`

Лекция 1. Типы и функции
 * [Типы](javascript/examples/1_1_types.js)
 * [Функции](javascript/examples/1_2_functions.js)
 * [Функции высшего порядка](javascript/examples/1_3_functions-hi.js).
   Обратите внимание на реализацию функции `mCurry`.
   Обратите внимание, что функции `array.map` и
   `array.reduce` (аналог `leftFold` входят в стандартную библиотеку).
 * [Пример: вектора и матрицы](javascript/examples/1_4_vectors.js).

Лекция 2. Объекты и замыкания
 * [Поля](javascript/examples/2_1_fields.js)
 * [Методы](javascript/examples/2_2_methods.js)
 * [Замыкания](javascript/examples/2_3_closures.js)
 * [Модули](javascript/examples/2_4_modules.js)
 * [Пример: стеки](javascript/examples/2_5_stacks.js)

Лекция 3. Другие возможности
 * [Обработка ошибок](javascript/examples/3_1_errors.js)
 * [Чего нет в JS](javascript/examples/3_2_no.js)
 * [Стандартная библиотека](javascript/examples/3_3_builtins.js)
 * [Работа со свойствами](javascript/examples/3_4_properties.js)
 * [Методы и классы](javascript/examples/3_5_classes.js)
 * [JS 6+](javascript/examples/3_6_js6.js)
 * Модули:
   [объявление](javascript/examples/3_7_js6_module.mjs)
   [использование](javascript/examples/3_7_js6_module_usage.mjs)
 * [Простейший ввод-вывод](javascript/examples/3_8_io.js)


## Тестовое задание на JavaScript

Это задание преднозначено для проверки правильности настройки 
[JavaScript](https://ecma-international.org/publications-and-standards/standards/ecma-262/).
Вам надо проверить, что оно успешно проверяется на вашем компьютере.

Модификации
 * *base*
    * Код решения `java-solutions/example.js` в 
      [репозитории решений](https://geo@www.kgeorgiy.info/git/geo/paradigms-2024-solutions/).
      Если всё настроено верно, то вам достаточно сделать `git pull --rebase` в своём репозитории,
      чтобы получить решение.
    * [Исходный код тестов](javascript/jstest/example/ExampleTest.java)
        * Запускать c аргументом `hard` или `easy`.

Запуск тестов
 * Для запуска тестов используется [GraalJS](https://github.com/graalvm/graaljs)
   (часть проекта [GraalVM](https://www.graalvm.org/)), но вам не требуется их скачивать.
 * Для запуска тестов рекомендуется использовать скрипты 
   [TestJS.cmd](javascript/TestJS.cmd) и [TestJS.sh](javascript/TestJS.sh)
    * Репозиторий должен быть скачан целиком.
    * Скрипты должны находиться в каталоге `javascript` (их нельзя перемещать, но можно вызывать из других каталогов).
    * В качестве аргументов командной строки указывается полное имя класса теста и модификация,
      например `jstest.example.ExampleTest hard base`.
 * Для самостоятельно запуска из консоли необходимо использовать командную строку вида:
    `java -ea --module-path=<js>/graal --class-path <js> jstest.example.ExampleTest {hard|easy} <variant>`, где
    * `-ea` – включение проверок времени исполнения;
    * `--module-path=<js>/graal` путь к модулям Graal (здесь и далее `<js>` путь к каталогу `javascript` этого репозитория);
    * `--class-path <js>` путь к откомпилированным тестам;
    * {`hard`|`easy`} указание тестируемой сложности;
    * `<variant>`} указание тестируемой модификации.
 * При запуске из IDE, обычно не требуется указывать `--class-path`, так как он формируется автоматически.
   Остальные опции все равно необходимо указать.
 * Troubleshooting
    * `Error occurred during initialization of boot layer java.lang.module.FindException: Module org.graalvm.truffle not found, required by jdk.internal.vm.compiler` 
      – неверно указан `--module-path`;
    * `Graal.js not found` – неверно указаны `--module-path`
    * `Error: Could not find or load main class jstest.example.ExampleTest` 
      – неверно указан `--class-path`;
    * `Exception in thread "main" java.lang.AssertionError: You should enable assertions by running 'java -ea jstest.functional.FunctionalExpressionTest'` 
      – не указана опция `-ea`;
    * `Exception in thread "main" jstest.EngineException: Script 'example.js' not found` 
      – в текущем каталоге отсутствует решение (`example.js`)


## Домашнее задание 5. Вычисление в различных типах

Модификации
 * *Base*
    * Класс `GenericTabulator` должен реализовывать интерфейс
      [Tabulator](java/expression/generic/Tabulator.java) и
      строить трехмерную таблицу значений заданного выражения.
        * `mode` – режим вычислений:
           * `i` – вычисления в `int` с проверкой на переполнение;
           * `d` – вычисления в `double` без проверки на переполнение;
           * `bi` – вычисления в `BigInteger`.
        * `expression` – выражение, для которого надо построить таблицу;
        * `x1`, `x2` – минимальное и максимальное значения переменной `x` (включительно)
        * `y1`, `y2`, `z1`, `z2` – аналогично для `y` и `z`.
        * Результат: элемент `result[i][j][k]` должен содержать
          значение выражения для `x = x1 + i`, `y = y1 + j`, `z = z1 + k`.
          Если значение не определено (например, по причине переполнения),
          то соответствующий элемент должен быть равен `null`.
    * [Исходный код тестов](java/expression/generic/GenericTest.java)
        * Первый аргумент: `easy` или `hard`
        * Последующие аргументы: модификации
 * *Ub* (32, 33)
    * Дополнительно реализуйте поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `b` – вычисления в `byte` без проверки на переполнение.
 * *Ubb* (34, 35)
    * Дополнительно реализуйте поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `b` – вычисления в `byte` без проверки на переполнение.
        * `bool` – вычисления в `boolean`.
 * *Cmm*
    * Дополнительно реализуйте унарные операции:
        * `count` – число установленных битов, `count 5` равно 2.
    * Дополнительно реализуйте бинарную операцию (минимальный приоритет):
        * `min` – минимум, `2 min 3` равно 2;
        * `max` – максимум, `2 max 3` равно 3.
 * *CmmUbb* (36, 37)
    * Дополнительно реализуйте поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `b` – вычисления в `byte` без проверки на переполнение,
        * `bool` – вычисления в `boolean`.
 * *CmmUbs* (38, 39)
    * Реализуйте операции из модификации *Cmm*.
    * Дополнительно реализуйте поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `b` – вычисления в `byte` без проверки на переполнение,
        * `sat` – вычисления с насыщением.


## Домашнее задание 4. Очереди

Модификации
 * *Базовая*
    * [Исходный код тестов](java/queue/QueueTest.java)
    * [Откомпилированные тесты](artifacts/queue/QueueTest.jar)
    * Для работы тестов необходимо добавить опцию JVM `--add-opens java.base/java.util=ALL-UNNAMED`
 * *Dedup* (32, 33)
    * Реализовать метод `dedup`, удаляющией из очереди подряд идущие повторяющиеся элементы.
    * Порядок элементов должен сохраняться.
 * *Distinct* (34, 35)
    * Реализовать метод `distinct`, удаляющией из очереди повторяющиеся элементы.
    * Порядок элементов должен сохраняться.
 * *FlatMap* (36-39)
    * Добавить в интерфейс очереди и реализовать метод
      `flatMap(function)` – создать очередь, содержащую результаты применения
      [функции](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Function.html)
      из элемента в список элементов
    * Исходная очередь должна остаться неизменной
    * Тип возвращаемой очереди должен соответствовать типу исходной очереди
    * Взаимный порядок элементов должен сохраняться
    * Дублирования кода быть не должно
 * *Reduce* (38-39)
    * Добавить в интерфейс очереди и реализовать метод
      `reduce(init, op)` – вернуть значение, полученное последовательным применением 
      [бинарного оператора](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/BinaryOperator.html)
      к `init` и элементам очереди в порядке от головы к хвосту
    * Исходная очередь должна остаться неизменной
    * Дублирования кода быть не должно


## Домашнее задание 3. Очередь на массиве

Модификации
 * *Базовая*
    * Классы должны находиться в пакете `queue`
    * [Исходный код тестов](java/queue/ArrayQueueTest.java)
    * [Откомпилированные тесты](artifacts/queue/ArrayQueueTest.jar)
 * *Deque*
    * Дополнительно реализовать методы
        * `push` – добавить элемент в начало очереди;
        * `peek` – вернуть последний элемент в очереди;
        * `remove` – вернуть и удалить последний элемент из очереди.
 * *CountIf* (32, 33)
    * Реализовать метод `countIf`, возвращающий число элеменов очереди, удовлетворяющих
      [предикату](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Predicate.html).
 * *IndexIf* (34, 35)
    * Реализовать метод
        * `indexIf`, возвращающий индекс первого элемента, удовлетворяющего
        [предикату](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Predicate.html);
        * `lastIndexIf`, возвращающий индекс последнего элемента, удовлетворяющего
        [предикату](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Predicate.html).
    * Индексы отсчитываются с головы очереди.
    * Если искомого элемента нет, методы должны возвращать `-1`.
 * *DequeCountIf* (36, 37)
    * Реализовать модификацию *Deque*;
    * Реализовать метод `countIf`, возвращающий число элеменов очереди, удовлетворяющих
      [предикату](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Predicate.html).
 * *DequeIndexIf* (38, 39)
    * Реализовать модификацию *Deque*;
    * Реализовать метод
        * `indexIf`, возвращающий индекс первого элемента, удовлетворяющего
        [предикату](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Predicate.html);
        * `lastIndexIf`, возвращающий индекс последнего элемента, удовлетворяющего
        [предикату](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/function/Predicate.html).
    * Индексы отсчитываются с головы очереди.
    * Если искомого элемента нет, методы должны возвращать `-1`.

Если при тестировании вы получаете ошибку
`... module java.base does not "opens java.util" to unnamed module ...`
(характерно для Java 17+), то при запуске тестов добавьте опции
`--add-opens` и `java.base/java.util=ALL-UNNAMED`.


## Домашнее задание 2. Бинарный поиск

Модификации
 * *Базовая*
    * Класс `BinarySearch` должен находиться в пакете `search`
    * [Исходный код тестов](java/search/BinarySearchTest.java)
    * [Откомпилированные тесты](artifacts/search/BinarySearchTest.jar)
 * *Choice* (32 - 35)
    * Если сумма всех чисел во входе чётная, то должна быть использована
      рекурсивная версия, иначе — итеративная.
 * *ClosestD* (32, 33)
    * На вход подаётся число `x` и непустой массив, отсортированный по невозрастанию.
    * Требуется вывести значение элемента массива наименее отличающегося от `x`.
    * Класс должен иметь имя `BinarySearchClosestD`
 * *ClosestA* (34, 35)
    * На вход подаётся число `x` и непустой массив, отсортированный по неубыванию.
    * Требуется вывести значение элемента массива наименее отличающегося от `x`.
    * Класс должен иметь имя `BinarySearchClosestA`
 * *ClosestI* (36, 37)
    * На вход подаётся число `x` и непустой массив, отсортированный по неубыванию.
    * Требуется вывести минимальный индекс элемента массива наименее отличающегося от `x`.
    * Требуется вывести минимальный индекс элемента массива наименее отличающегося от `x`.
    * Класс должен иметь имя `BinarySearchClosestI`
 * *Shift* (38, 39)
    * На вход подается число `x` и массив `a`,
      полученный циклическим сдвигом отсортированного (строго) по возрастанию массива.
    * Требуется вывести индекс первого вхождения `x` в `a` или `-1`, если `x` не входит в `a`.
    * Класс должен иметь имя `BinarySearchShift`


Для того, чтобы протестировать базовую модификацию домашнего задания:

 1. Скачайте тесты ([BinarySearchTest.jar](artifacts/search/BinarySearchTest.jar))
 1. Откомпилируйте `BinarySearch.java`
 1. Проверьте, что создался `BinarySearch.class`
 1. В каталоге, в котором находится `search/BinarySearch.class` выполните команду

    ```
       java -jar <путь к BinarySearchTest.jar> Base
    ```

    Например, если `BinarySearchTest.jar` находится в текущем каталоге,
    а `BinarySearch.class` в каталоге `search`, выполните команду

    ```
        java -jar BinarySearchTest.jar Base
    ```


## Домашнее задание 1. Обработка ошибок

Модификации
 * *Base*
    * Класс `ExpressionParser` должен реализовывать интерфейс
        [TripleParser](java/expression/exceptions/TripleParser.java)
    * Классы `CheckedAdd`, `CheckedSubtract`, `CheckedMultiply`,
        `CheckedDivide` и `CheckedNegate` должны реализовывать интерфейс
        [TripleExpression](java/expression/TripleExpression.java)
    * Нельзя использовать типы `long` и `double`
    * Нельзя использовать методы классов `Math` и `StrictMath`
    * [Исходный код тестов](java/expression/exceptions/ExceptionsTest.java)
        * Первый аргумент: `easy` или `hard`
        * Последующие аргументы: модификации
 * *Zeroes* (32, 33)
    * Дополнительно реализуйте унарные операции
      * `l0` – число старших нулевых бит, `l0 123456` равно 15;
      * `t0` – число младших нулевых бит, `t0 123456` равно 6.
 * *PowLog2* (34, 35)
    * Дополнительно реализуйте унарные операции:
        * `log2` – логарифм по уснованию 2, `log2 10` равно 3;
        * `pow2` – два в степени, `pow2 4` равно 16.
 * *MinMax* (36-39)
    * Дополнительно реализуйте бинарные операции (минимальный приоритет):
        * `min` – минимум, `2 min 3` равно 2;
        * `max` – максимум, `2 max 3` равно 3.
 * *Shifts* (38, 39)
    * Дополнительно реализуйте бинарные операции с минимальным приоритетом:
        * `<<` – сдвиг влево (`1 << 5 + 3` равно `1 << (5 + 3)` равно 256);
        * `>>` – сдвиг вправо (`1024 >> 5 + 3` равно `1024 >> (5 + 3)` равно 4);
        * `>>>` – арифметический сдвиг вправо (`-1024 >>> 5 + 3` равно `1024 >>> (5 + 3)` равно -4);
 * *Parens* (34-39)
    * Дополнительно реализуйте поддержку квадратных и фигурных скобок:
        * `([{1 + 2} * 3] + 5)` равно 14;
        * скобки дожны быть парными, `(1 + 2]` — ошибка.
 * *List* (32-39)
    * Класс `ExpressionParser` дополнительно должен реализовывать интерфейс
        [ListParser](java/expression/exceptions/ListParser.java)
        * порядок значений переменных, передаваемых в `evaluate`
          соответствует порядку переменных в вызове `parse`;
        * например, `parse("a + b * b", List.of("a", "b")).evaluate(List.of(2, 3))`
          равно 11;
        * у класса `Variable` должен быть конструктор от `int` — номера переменной.
